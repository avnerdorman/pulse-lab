<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Pulse Grouping Lab — Standalone</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <style>
    /* Basic layout */
    body {
      margin: 0;
      padding: 16px;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      background: #f7f7f7;
      color: #222;
    }

    .lab-container {
      max-width: 960px;
      margin: 0 auto;
      background: #ffffff;
      border-radius: 10px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
      padding: 16px 20px 20px;
      box-sizing: border-box;
    }

    h1 {
      font-size: 1.4rem;
      margin: 0 0 4px;
    }

    .lab-subtitle {
      font-size: 0.9rem;
      color: #555;
      margin-bottom: 12px;
    }

    .controls-row {
      display: flex;
      flex-wrap: wrap;
      gap: 12px 18px;
      align-items: center;
      margin-bottom: 12px;
      font-size: 0.9rem;
    }

    .control-group {
      display: flex;
      align-items: center;
      gap: 6px;
      flex-wrap: wrap;
    }

    label {
      font-weight: 500;
    }

    input[type="number"], select {
      padding: 4px 6px;
      font-size: 0.9rem;
    }

    input[type="range"] {
      width: 140px;
    }

    .btn {
      border: 1px solid #ccc;
      background: #f3f3f3;
      border-radius: 999px;
      padding: 4px 12px;
      font-size: 0.9rem;
      cursor: pointer;
      transition: background 0.15s ease, border-color 0.15s ease;
    }

    .btn-primary {
      background: #0b57d0;
      color: #fff;
      border-color: #0b57d0;
    }

    .btn-primary:hover {
      background: #0947aa;
      border-color: #0947aa;
    }

    .btn:hover {
      background: #e9e9e9;
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: default;
    }

    .grid-wrapper {
      margin-top: 10px;
      overflow-x: auto;
      padding-bottom: 10px;
    }

    /* Grid layout */
    .grid {
      border-collapse: collapse;
      border-spacing: 0;
      width: 100%;
      min-width: 520px; /* keeps labels readable */
    }

    .grid-row-label {
      white-space: nowrap;
      text-align: right;
      padding-right: 8px;
      font-size: 0.85rem;
      color: #444;
      width: 80px;
    }

    .pulse-dot-row,
    .track-row {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 2px 0;
    }

    .pulse-dot {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      border: 1px solid #bbb;
      background: #fdfdfd;
      box-sizing: border-box;
      flex: 0 0 16px;
    }

    .pulse-dot.current {
      background: #0b57d0;
      border-color: #0b57d0;
    }

    .cell {
      width: 18px;
      height: 18px;
      border-radius: 4px;
      border: 1px solid #ddd;
      background: #fafafa;
      box-sizing: border-box;
      cursor: pointer;
      flex: 0 0 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.7rem;
      user-select: none;
    }

    .cell.track-a-on {
      background: #ffe4c4;
      border-color: #f0a64b;
    }

    .cell.track-b-on {
      background: #e0f3ff;
      border-color: #5aa5e6;
    }

    .cell.track-c-on {
      background: #e6ffe4;
      border-color: #5bbf65;
    }

    .cell.col-highlight {
      box-shadow: 0 0 0 2px rgba(11,87,208,0.2);
    }

    .grid-header-row {
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 0.7rem;
      color: #777;
      margin-bottom: 3px;
    }

    .grid-header-row .grid-row-label {
      visibility: hidden; /* align with other labels but hide text */
    }

    .grid-header-num {
      width: 18px;
      text-align: center;
      flex: 0 0 18px;
    }

    .export-section {
      margin-top: 10px;
    }

    .export-section textarea {
      width: 100%;
      min-height: 110px;
      font-family: "SF Mono", Menlo, Consolas, "Liberation Mono", monospace;
      font-size: 0.8rem;
      padding: 8px;
      box-sizing: border-box;
      border-radius: 6px;
      border: 1px solid #ccc;
      resize: vertical;
    }

    .export-buttons {
      margin-top: 6px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    .export-hint {
      font-size: 0.8rem;
      color: #666;
      margin-top: 6px;
    }

    @media (max-width: 600px) {
      .lab-container {
        padding: 12px;
        border-radius: 0;
        box-shadow: none;
      }
      .grid {
        min-width: 400px;
      }
    }
  </style>
</head>
<body>
  <div class="lab-container">
    <h1>Pulse Grouping Lab</h1>
    <div class="lab-subtitle">
      Top row = pulse (all onsets). Click in the three rows below to add or remove onsets.
    </div>

    <div class="controls-row">
      <div class="control-group">
        <label for="length-select">Pulses:</label>
        <select id="length-select">
          <!-- 4–36 -->
        </select>
      </div>

      <div class="control-group">
        <label for="tempo-input">Tempo (BPM):</label>
        <input id="tempo-input" type="number" min="40" max="240" value="90" />
      </div>

      <div class="control-group">
        <label for="repeats-input">Repeats:</label>
        <input id="repeats-input" type="number" min="1" max="32" value="8" />
      </div>

      <div class="control-group">
        <button id="play-btn" class="btn btn-primary">Play</button>
        <button id="stop-btn" class="btn">Stop</button>
      </div>

      <div class="control-group">
        <button id="clear-a" class="btn">Clear A</button>
        <button id="clear-b" class="btn">Clear B</button>
        <button id="clear-c" class="btn">Clear C</button>
      </div>
    </div>

    <div class="grid-wrapper">
      <div id="grid-header" class="grid-header-row"></div>
      <div id="grid-container"></div>
    </div>

    <div class="export-section">
      <button id="export-btn" class="btn">Generate Pattern Text</button>
      <div class="export-buttons">
        <button id="copy-btn" class="btn">Copy to clipboard</button>
      </div>
      <textarea id="export-area" placeholder="Click &quot;Generate Pattern Text&quot; to export…"></textarea>
      <div class="export-hint">
        You can paste this into a document, Moodle submission, or email. “X” = onset, “.” = silence.
      </div>
    </div>
  </div>

  <script>
    // ---- State ----
    const MAX_PULSES = 36;
    let patternLength = 16;
    let repeats = 8;
    let tempo = 90;

    let trackA = [];
    let trackB = [];
    let trackC = [];

    let isPlaying = false;
    let currentStep = 0;
    let totalSteps = patternLength * repeats;
    let intervalId = null;

    // Audio context: created immediately, resumed on first Play
    const AudioContextClass = window.AudioContext || window.webkitAudioContext;
    const audioCtx = AudioContextClass ? new AudioContextClass() : null;
    let audioUnlocked = false;

    // ---- DOM Elements ----
    const lengthSelect = document.getElementById("length-select");
    const tempoInput = document.getElementById("tempo-input");
    const repeatsInput = document.getElementById("repeats-input");
    const playBtn = document.getElementById("play-btn");
    const stopBtn = document.getElementById("stop-btn");
    const clearABtn = document.getElementById("clear-a");
    const clearBBtn = document.getElementById("clear-b");
    const clearCBtn = document.getElementById("clear-c");
    const gridHeader = document.getElementById("grid-header");
    const gridContainer = document.getElementById("grid-container");
    const exportBtn = document.getElementById("export-btn");
    const exportArea = document.getElementById("export-area");
    const copyBtn = document.getElementById("copy-btn");

    // ---- Helpers ----

    function initLengthSelect() {
      for (let n = 4; n <= MAX_PULSES; n++) {
        const opt = document.createElement("option");
        opt.value = n;
        opt.textContent = n;
        if (n === patternLength) opt.selected = true;
        lengthSelect.appendChild(opt);
      }
    }

    function initPattern(len) {
      patternLength = len;
      trackA = new Array(patternLength).fill(false);
      trackB = new Array(patternLength).fill(false);
      trackC = new Array(patternLength).fill(false);
      currentStep = 0;
      totalSteps = patternLength * repeats;
    }

    function buildGridHeader() {
      gridHeader.innerHTML = "";

      const labelCell = document.createElement("div");
      labelCell.className = "grid-row-label";
      labelCell.textContent = "";
      gridHeader.appendChild(labelCell);

      for (let i = 0; i < patternLength; i++) {
        const numCell = document.createElement("div");
        numCell.className = "grid-header-num";
        numCell.textContent = i;
        gridHeader.appendChild(numCell);
      }
    }

    function buildGrid() {
      gridContainer.innerHTML = "";

      // Pulse row
      const pulseRow = document.createElement("div");
      pulseRow.className = "pulse-dot-row";

      const pulseLabel = document.createElement("div");
      pulseLabel.className = "grid-row-label";
      pulseLabel.textContent = "Pulse";
      pulseRow.appendChild(pulseLabel);

      for (let i = 0; i < patternLength; i++) {
        const dot = document.createElement("div");
        dot.className = "pulse-dot";
        dot.dataset.index = i;
        pulseRow.appendChild(dot);
      }

      gridContainer.appendChild(pulseRow);

      // Track rows (A, B, C)
      buildTrackRow("Track A", "A", trackA);
      buildTrackRow("Track B", "B", trackB);
      buildTrackRow("Track C", "C", trackC);

      updateCurrentPulseHighlight(-1);
    }

    function buildTrackRow(labelText, trackId, trackArray) {
      const row = document.createElement("div");
      row.className = "track-row";

      const label = document.createElement("div");
      label.className = "grid-row-label";
      label.textContent = labelText;
      row.appendChild(label);

      for (let i = 0; i < patternLength; i++) {
        const cell = document.createElement("div");
        cell.className = "cell";
        cell.dataset.index = i;
        cell.dataset.track = trackId;

        if (trackId === "A" && trackArray[i]) {
          cell.classList.add("track-a-on");
        } else if (trackId === "B" && trackArray[i]) {
          cell.classList.add("track-b-on");
        } else if (trackId === "C" && trackArray[i]) {
          cell.classList.add("track-c-on");
        }

        cell.addEventListener("click", onCellClick);
        cell.addEventListener("mouseenter", () => highlightColumn(i, true));
        cell.addEventListener("mouseleave", () => highlightColumn(i, false));

        row.appendChild(cell);
      }

      gridContainer.appendChild(row);
    }

    function onCellClick(e) {
      const cell = e.currentTarget;
      const index = parseInt(cell.dataset.index, 10);
      const track = cell.dataset.track;
      if (Number.isNaN(index)) return;

      if (track === "A") {
        trackA[index] = !trackA[index];
      } else if (track === "B") {
        trackB[index] = !trackB[index];
      } else if (track === "C") {
        trackC[index] = !trackC[index];
      }

      buildGrid(); // simpler to rebuild than manually toggle classes
    }

    function highlightColumn(index, on) {
      const dots = gridContainer.querySelectorAll(`.pulse-dot[data-index="${index}"]`);
      const cells = gridContainer.querySelectorAll(`.cell[data-index="${index}"]`);
      dots.forEach(d => {
        if (on) d.classList.add("col-highlight");
        else d.classList.remove("col-highlight");
      });
      cells.forEach(c => {
        if (on) c.classList.add("col-highlight");
        else c.classList.remove("col-highlight");
      });
    }

    function updateCurrentPulseHighlight(stepIndex) {
      const allDots = gridContainer.querySelectorAll(".pulse-dot");
      allDots.forEach(dot => dot.classList.remove("current"));

      if (stepIndex < 0) return;
      const patternIndex = stepIndex % patternLength;
      const currentDot = gridContainer.querySelector(`.pulse-dot[data-index="${patternIndex}"]`);
      if (currentDot) {
        currentDot.classList.add("current");
      }
    }

    // ---- Audio ----

    function ensureAudioUnlocked() {
      if (!audioCtx || audioUnlocked) return;
      // resume on first user gesture (Play)
      audioCtx.resume().then(() => {
        audioUnlocked = true;
      }).catch(err => {
        console.warn("AudioContext resume failed:", err);
      });
    }

    function triggerClick(freq, timeOffsetSec) {
      if (!audioCtx) return;

      const t = audioCtx.currentTime + timeOffsetSec;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();

      osc.type = "square";
      osc.frequency.value = freq;
      gain.gain.setValueAtTime(0.18, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.08);

      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.start(t);
      osc.stop(t + 0.09);
    }

    function step() {
      const idx = currentStep % patternLength;

      // pulse click (soft low)
      triggerClick(220, 0);

      if (trackA[idx]) triggerClick(440, 0);
      if (trackB[idx]) triggerClick(660, 0);
      if (trackC[idx]) triggerClick(880, 0);

      updateCurrentPulseHighlight(currentStep);

      currentStep++;
      if (currentStep >= totalSteps) {
        stopPlayback();
      }
    }

    function startPlayback() {
      if (isPlaying) return;
      ensureAudioUnlocked();
      if (!audioCtx) {
        alert("Web Audio is not supported in this browser.");
        return;
      }

      // update from inputs
      tempo = clampInt(parseInt(tempoInput.value, 10), 40, 240, 90);
      tempoInput.value = tempo;
      repeats = clampInt(parseInt(repeatsInput.value, 10), 1, 32, 8);
      repeatsInput.value = repeats;

      totalSteps = patternLength * repeats;
      currentStep = 0;
      updateCurrentPulseHighlight(-1);

      const intervalMs = (60_000 / tempo); // 1 pulse = quarter note

      isPlaying = true;
      updatePlayButton();
      step(); // immediate first step
      intervalId = window.setInterval(step, intervalMs);
    }

    function stopPlayback() {
      if (!isPlaying) return;
      isPlaying = false;
      updatePlayButton();
      if (intervalId !== null) {
        window.clearInterval(intervalId);
        intervalId = null;
      }
      currentStep = 0;
      updateCurrentPulseHighlight(-1);
    }

    function togglePlay() {
      if (!isPlaying) startPlayback();
      else stopPlayback();
    }

    function updatePlayButton() {
      playBtn.textContent = isPlaying ? "Pause" : "Play";
    }

    function clampInt(val, min, max, fallback) {
      if (Number.isNaN(val)) return fallback;
      return Math.min(max, Math.max(min, val));
    }

    // ---- Export ----

    function buildExportText() {
      const lines = [];
      lines.push(`Tempo: ${tempo} BPM`);
      lines.push(`Pattern length: ${patternLength} pulses`);
      lines.push(`Repeats: ${repeats}`);
      lines.push("");

      // Pulse line
      let pulseLine = "Pulses: ";
      for (let i = 0; i < patternLength; i++) {
        pulseLine += "● ";
      }
      lines.push(pulseLine.trim());

      function lineForTrack(label, arr) {
        let s = `${label}: `;
        for (let i = 0; i < patternLength; i++) {
          s += (arr[i] ? "X " : ". ");
        }
        return s.trim();
      }

      lines.push(lineForTrack("Track A", trackA));
      lines.push(lineForTrack("Track B", trackB));
      lines.push(lineForTrack("Track C", trackC));

      return lines.join("\n");
    }

    function exportPattern() {
      exportArea.value = buildExportText();
    }

    function copyExport() {
      const text = exportArea.value || buildExportText();
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(text).then(() => {
          // optional: small confirmation
        }).catch(err => {
          console.warn("Clipboard copy failed:", err);
          alert("Copy failed. You can still select the text manually.");
        });
      } else {
        alert("Clipboard API not available. Select the text and copy manually.");
      }
    }

    // ---- Wiring ----

    function attachEvents() {
      playBtn.addEventListener("click", togglePlay);
      stopBtn.addEventListener("click", stopPlayback);

      lengthSelect.addEventListener("change", () => {
        const len = clampInt(parseInt(lengthSelect.value, 10), 4, MAX_PULSES, 16);
        initPattern(len);
        buildGridHeader();
        buildGrid();
      });

      tempoInput.addEventListener("change", () => {
        tempo = clampInt(parseInt(tempoInput.value, 10), 40, 240, 90);
        tempoInput.value = tempo;
      });

      repeatsInput.addEventListener("change", () => {
        repeats = clampInt(parseInt(repeatsInput.value, 10), 1, 32, 8);
        repeatsInput.value = repeats;
        totalSteps = patternLength * repeats;
      });

      clearABtn.addEventListener("click", () => {
        trackA = new Array(patternLength).fill(false);
        buildGrid();
      });

      clearBBtn.addEventListener("click", () => {
        trackB = new Array(patternLength).fill(false);
        buildGrid();
      });

      clearCBtn.addEventListener("click", () => {
        trackC = new Array(patternLength).fill(false);
        buildGrid();
      });

      exportBtn.addEventListener("click", exportPattern);
      copyBtn.addEventListener("click", copyExport);
    }

    // ---- Init ----
    initLengthSelect();
    initPattern(patternLength);
    buildGridHeader();
    buildGrid();
    attachEvents();
  </script>
</body>
</html>
